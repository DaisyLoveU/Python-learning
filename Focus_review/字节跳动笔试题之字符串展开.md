
小赵和小钱在练字，小钱对小赵说：你知道吗，我练习的字是有蕴含的。

小赵不服气了，凭什么你的就有蕴含呢？

小钱说，你所看到的并不是我真正练习的字，你需要将我现在写下的字符串里面“%”和“#”之间的字重复符号前的那么多倍，才能看到我真正写的是什么。

你能帮帮小赵吗？

```
说明：可能存在嵌套的情况，如“3%g2%n##”，返回“gnngnngnn”，输入输出的字符串长度都不超过10000。

输入字符串保证合法，且输出的字符串中只包含大小写英文字母。

输入格式
一行带数字和嵌套括号的字符串。

输出格式
展开的字符串。

输入样例：
3%acm#2%acm#
输出样例：
acmacmacmacmacm
```

思路：  
  
存在嵌套的模式，需要考虑一下递归了，我们人脑做这道题是从里到外，先把最里层的模式串解决，再跳到外面一层，一层一层出去，最终是正确结果。  
  
然而，使用代码的话，只能是从头到尾遍历字符串，如果遇到数字就说明接下来可能是进入模式串，然后一层一层进入到最里层的模式串，解决最里层，然后一层一层返回结果  
  
有些边界值需要注意  

```
我们举例说明一下，
eg： input aaa11%x3%y#zz#
i 从 0 开始，遇到的是字母，则直接添加至 res 中，
直到 s[i] 是数字，则接下来有两种情况：
  1. s[i+1] 还是数字， 我们需要记录需要重复的次数 times，转至 情况2
  2. s[i+1] 是 %，那么接下来有
    a. % 后面是字母
    b. % 后面是数字，进入下一个模式串中
  .
  .
  .
  当遇到第一个 # ，我们找到了最里层的结尾标志，将需要重复的字符串返回，并进行重复操作
  然后就是一层层返回值
  最终得到答案
```


```python
def dfs():
    res = ''
    global i
    while i < len(s):
        cur = s[i]
        if cur == '#': return res
        if '0' <= cur <= '9':
            times = ''
            while s[i] != '%':
                times += s[i]
                i += 1
            i += 1
            tmp = dfs()
            res += int(times) * tmp
        else:
            res += cur
        i += 1
    return res
if __name__ == '__main__':
    s = input()
    i = 0
    print(dfs())
```

    aaa11%x3%y#zz#
    aaaxyyyzzxyyyzzxyyyzzxyyyzzxyyyzzxyyyzzxyyyzzxyyyzzxyyyzzxyyyzzxyyyzz
    
